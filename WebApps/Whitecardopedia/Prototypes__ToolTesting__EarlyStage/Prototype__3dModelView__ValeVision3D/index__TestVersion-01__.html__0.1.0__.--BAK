<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whitecard 3D Model Viewer - ValeVision3D</title>
    
    <!-- ----------------------------------------------------------------- -->
    <!-- REGION  |  External CDN Library Imports                           -->
    <!-- ----------------------------------------------------------------- -->
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Babylon.js Core and Loaders -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    
    <!-- endregion -------------------------------------------------------- -->
    


    <!-- ----------------------------------------------------------------- -->
    <!-- REGION  |  CSS Styling - ValeVision3D Standards              -->
    <!-- ----------------------------------------------------------------- -->
    
    <style>
        /* Base Layout - Full Screen Canvas */
        * {
            margin                             : 0;
            padding                            : 0;
            box-sizing                         : border-box;
        }
        
        html, body {
            width                              : 100%;
            height                             : 100%;
            overflow                           : hidden;
            background-color                   : #ffffff;
            font-family                        : -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        /* Canvas Container */
        #root {
            width                              : 100vw;
            height                             : 100vh;
            display                            : flex;
            align-items                        : center;
            justify-content                    : center;
        }
        
        /* Babylon.js Render Canvas */
        #renderCanvas {
            width                              : 100%;
            height                             : 100%;
            touch-action                       : none;
            outline                            : none;
            display                            : block;
        }
        
        /* Loading Indicator */
        .loading-indicator {
            position                           : absolute;
            top                                : 50%;
            left                               : 50%;
            transform                          : translate(-50%, -50%);
            font-size                          : 1.2rem;
            color                              : #172b3a;
            text-align                         : center;
        }
        
        /* Debug Info Overlay */
        .debug-info {
            position                           : absolute;
            top                                : 10px;
            left                               : 10px;
            background-color                   : rgba(0, 0, 0, 0.7);
            color                              : #00ff00;
            padding                            : 10px;
            font-family                        : 'Courier New', monospace;
            font-size                          : 0.85rem;
            border-radius                      : 4px;
            z-index                            : 1000;
            max-width                          : 350px;
        }
        
        .debug-info h4 {
            margin                             : 0 0 8px 0;
            color                              : #ffffff;
            font-size                          : 0.95rem;
        }
        
        .debug-info p {
            margin                             : 4px 0;
            line-height                        : 1.4;
        }
    </style>
    
    <!-- endregion -------------------------------------------------------- -->
    
    
    <!-- ----------------------------------------------------------------- -->
    <!-- REGION  |  Application Configuration Data                         -->
    <!-- ----------------------------------------------------------------- -->
    
    <script id="appConfigData" type="application/json">
        {
            "appMetadata": {
                "appName": "Whitecardopedia__ValeVision3D",
                "appVersion": "1.0.0",
                "appDescription": "A 3D model viewer for the Vale Garden Houses board to review whitecard images (simple massing models).",
                "appAuthor": "Adam Noble - Noble Architecture",
                "appCreated": "2025"
            },
            "appConfig": {
                "devMode_Enabled": true,
                "devMode_ShowDebugInfo": true,
                "devMode_ShowAxisHelper": true,
                "devMode_LogCameraPosition": false,
                "devMode_Description": "Various typical app config options, enables debug tools and analysis tools"
            },
            "navigationConfig": {
                "navigationMode_MoveSpeed_MPH": 20.0,
                "navigationMode_MoveSpeed_Description": "This value is the max speed of the camera movement in Miles Per Hour.",
                "navigationMode_AngularSensitivity": 1000,
                "navigationMode_AngularSensitivity_Description": "Mouse rotation sensitivity (higher = less sensitive).",
                "navigationMode_Inertia": 0.5,
                "navigationMode_Inertia_Description": "Movement smoothing (0 = no smoothing, 1 = maximum smoothing).",
                "navigationMode_EnableCollision": false,
                "navigationMode_EnableGravity": false
            },
            "renderConfig": {
                "render_EnableAntialiasing": true,
                "render_BackgroundColor_R": 1.0,
                "render_BackgroundColor_G": 1.0,
                "render_BackgroundColor_B": 1.0,
                "render_BackgroundColor_A": 1.0,
                "render_Description": "Rendering pipeline configuration options."
            },
            "lightingConfig": {
                "lighting_HemisphereIntensity": 1.2,
                "lighting_HemisphereDiffuse_R": 1.0,
                "lighting_HemisphereDiffuse_G": 1.0,
                "lighting_HemisphereDiffuse_B": 1.0,
                "lighting_HemisphereSpecular_R": 0.02,
                "lighting_HemisphereSpecular_G": 0.02,
                "lighting_HemisphereSpecular_B": 0.02,
                "lighting_HemisphereGround_R": 0.95,
                "lighting_HemisphereGround_G": 0.95,
                "lighting_HemisphereGround_B": 0.95,
                "lighting_DirectionalIntensity": 0.3,
                "lighting_DirectionalDirection_X": -0.5,
                "lighting_DirectionalDirection_Y": -1.0,
                "lighting_DirectionalDirection_Z": -0.3,
                "lighting_Description": "Lighting configuration optimized for whitecard aesthetic."
            },
            "edgeConfig": {
                "edge_Width": 2.0,
                "edge_Color_R": 20,
                "edge_Color_G": 20,
                "edge_Color_B": 20,
                "edge_SmoothingAngle": 35,
                "edge_EnableSilhouetteEdges": true,
                "edge_Description": "Edge rendering configuration for whitecard aesthetic. Color values are 0-255. SmoothingAngle controls which edges are hidden (edges with angles below this are considered smooth and hidden)."
            },
            "rendererConfig_LineStyles": {
                "lineStyles_ProfileIntensity": 4.0,
                "lineStyles_CurvedSurfaceBoost": 40.0,
                "lineStyles_Description": "Line style rendering configuration for SketchUp-style profiles. ProfileIntensity controls the strength of silhouette edge detection (higher = thicker/more visible profile edges). CurvedSurfaceBoost amplifies profile edges on rounded surfaces (recommended 4.0-6.0)."
            },
            "modelConfig": {
                "model_DefaultURL": "https://cdn.noble-architecture.com/VaApps/3dAssets/Test__SketchUpExport__UsingOwnGlbExporter__3.0.0__.glb",
                "model_AutoCenter": true,
                "model_AutoFrameCamera": true,
                "model_CameraDistanceMultiplier": 2.0,
                "model_Description": "Model loading and positioning configuration.",
                "model_Rotation_Description": "These values are the global rotation of the model in degrees.",
                "model_Rotation_X__Notes": "This corresponds to the X rotation of the model in degrees. (Red Axis In Browser View)",
                "model_Rotation_X": 0,
                "model_Rotation_Y__Notes": "This corresponds to the Y rotation of the model in degrees. (Blue Axis In Browser View)",
                "model_Rotation_Y": 180,
                "model_Rotation_Z__Notes": "This corresponds to the Z rotation of the model in degrees. (Green Axis In Browser View)",
                "model_Rotation_Z": 0,
                "model_Translation_Description": "These values are the global translation of the model in Babylon.js units (meters).",
                "model_Translation_X__Notes": "This corresponds to the X translation of the model in units. (Red Axis In Browser View)",
                "model_Translation_X": 0,
                "model_Translation_Y__Notes": "This corresponds to the Y translation of the model in units. (Green Axis In Browser View)",
                "model_Translation_Y": 15,
                "model_Translation_Z__Notes": "This corresponds to the Z translation of the model in units. (Green Axis In Browser View)",
                "model_Translation_Z": 0
            }
        }
    </script>
    
    <!-- endregion -------------------------------------------------------- -->
    
</head>
<body>
    <!-- ----------------------------------------------------------------- -->
    <!-- REGION  |  React Application Root Container                       -->
    <!-- ----------------------------------------------------------------- -->
    
    <div id="root"></div>
    
    <!-- endregion -------------------------------------------------------- -->
    
    
    <!-- ----------------------------------------------------------------- -->
    <!-- REGION  |  React + Babylon.js Application Logic                    -->
    <!-- ----------------------------------------------------------------- -->
    
    <script type="text/babel">
        // -----------------------------------------------------------------------------
        // REGION | Application Configuration Management
        // -----------------------------------------------------------------------------
        
            // MODULE VARIABLES | Application Configuration State
            // ------------------------------------------------------------
            let appConfig        = null;                                     // <-- Global config object
            let appMetadata      = null;                                     // <-- App metadata
            let navConfig        = null;                                     // <-- Navigation configuration
            let renderConfig     = null;                                     // <-- Render configuration
            let lightingConfig   = null;                                     // <-- Lighting configuration
            let edgeConfig       = null;                                     // <-- Edge rendering configuration
            let lineStylesConfig = null;                                     // <-- Line styles rendering configuration
            let modelConfig      = null;                                     // <-- Model configuration
            // ---------------------------------------------------------------
            
            // FUNCTION | Load Application Configuration from JSON
            // ------------------------------------------------------------
            function loadAppConfiguration() {
                try {
                    const configElement = document.getElementById('appConfigData');  // <-- Get config script element
                    if (!configElement) {
                        console.error('Configuration data not found');      // <-- Log error
                        return false;                                        // <-- Return failure
                    }
                    
                    const configData = JSON.parse(configElement.textContent);  // <-- Parse JSON config
                    
                    // Store configuration sections globally
                    appMetadata      = configData.appMetadata;               // <-- Store app metadata
                    appConfig        = configData.appConfig;                 // <-- Store app config
                    navConfig        = configData.navigationConfig;          // <-- Store navigation config
                    renderConfig     = configData.renderConfig;              // <-- Store render config
                    lightingConfig   = configData.lightingConfig;            // <-- Store lighting config
                    edgeConfig       = configData.edgeConfig;                // <-- Store edge rendering config
                    lineStylesConfig = configData.rendererConfig_LineStyles; // <-- Store line styles rendering config
                    modelConfig      = configData.modelConfig;               // <-- Store model config
                    
                    // Log configuration load if dev mode enabled
                    if (appConfig?.devMode_Enabled === true) {
                        console.log('=== ValeVision3D Configuration Loaded ===');
                        console.log(`App: ${appMetadata.appName} v${appMetadata.appVersion}`);
                        console.log(`Author: ${appMetadata.appAuthor}`);
                        console.log('Dev Mode: ENABLED');
                        console.log('=======================================');
                    }
                    
                    return true;                                             // <-- Return success
                    
                } catch (error) {
                    console.error('Error loading configuration:', error);   // <-- Log error
                    return false;                                            // <-- Return failure
                }
            }
            // ---------------------------------------------------------------
            
            // HELPER FUNCTION | Convert MPH to Babylon.js Units Per Second
            // ---------------------------------------------------------------
            function convertMPHtoBabylonSpeed(mph) {
                // Babylon.js uses units per second
                // 1 mph = 0.44704 meters/second
                // Assuming 1 Babylon unit = 1 meter
                const metersPerSecond = mph * 0.44704;                       // <-- Convert MPH to m/s
                return metersPerSecond;                                      // <-- Return Babylon speed
            }
            // ---------------------------------------------------------------
            
            // HELPER FUNCTION | Get Configuration Value with Fallback
            // ---------------------------------------------------------------
            function getConfigValue(configObject, key, fallback) {
                return (configObject && configObject[key] !== undefined) ? configObject[key] : fallback;
            }
            // ---------------------------------------------------------------
            
            // Initialize configuration immediately
            loadAppConfiguration();                                          // <-- Load config on script load
            
        // endregion -------------------------------------------------------------------
        
        
        // -----------------------------------------------------------------------------
        // REGION | SketchUp Model Processing and Corrections
        // -----------------------------------------------------------------------------
        
            // HELPER FUNCTION | Calculate Scene Bounding Box
            // ---------------------------------------------------------------
            function calculateSceneBounds(meshes) {
                let min = new BABYLON.Vector3(Infinity, Infinity, Infinity);
                let max = new BABYLON.Vector3(-Infinity, -Infinity, -Infinity);
                
                meshes.forEach(mesh => {
                    if (mesh.getBoundingInfo) {
                        const boundingBox = mesh.getBoundingInfo().boundingBox;
                        min = BABYLON.Vector3.Minimize(min, boundingBox.minimumWorld);
                        max = BABYLON.Vector3.Maximize(max, boundingBox.maximumWorld);
                    }
                });
                
                const center = BABYLON.Vector3.Center(min, max);             // <-- Calculate center
                const size = max.subtract(min);                              // <-- Calculate size
                const maxDimension = Math.max(size.x, size.y, size.z);      // <-- Get largest dimension
                
                return { min, max, center, size, maxDimension };            // <-- Return bounds info
            }
            // ---------------------------------------------------------------
            
            // HELPER FUNCTION | Preprocess Meshes for Universal Smooth Shading
            // ---------------------------------------------------------------
            function preprocessMeshesForSmoothing(meshes) {
                meshes.forEach(mesh => {
                    if (!mesh.material && !mesh.subMeshes) return;                  // <-- Skip non-renderable meshes
                    
                    try {
                        // Ensure proper normals computation for all meshes
                        // This helps Babylon.js edge rendering work correctly with face angles
                        const vertexData = BABYLON.VertexData.ExtractFromMesh(mesh);
                        if (vertexData && vertexData.positions && vertexData.indices) {
                            // Recompute normals to ensure they're accurate for edge detection
                            // Edge rendering uses face normal angles, so accurate normals are crucial
                            if (!vertexData.normals || vertexData.normals.length === 0) {
                                vertexData.normals = [];                             // <-- Initialize normals array
                            }
                            
                            BABYLON.VertexData.ComputeNormals(
                                vertexData.positions, 
                                vertexData.indices, 
                                vertexData.normals,
                                { useRightHandedSystem: false }                     // <-- Babylon uses left-handed system
                            );
                            vertexData.applyToMesh(mesh);                           // <-- Apply computed normals
                        }
                        
                    } catch (error) {
                        console.warn(`Could not preprocess mesh: ${mesh.name}`, error);
                    }
                });
            }
            // ---------------------------------------------------------------
            
            // HELPER FUNCTION | Apply Global Rotation to Model Meshes
            // ---------------------------------------------------------------
            function applyGlobalModelRotation(meshes, scene, rotationXDeg, rotationYDeg, rotationZDeg) {
                if (meshes.length === 0) return;                                // <-- Exit if no meshes
                
                // Convert degrees to radians for Babylon.js rotation
                const rotationXRad = (rotationXDeg * Math.PI) / 180;            // <-- Convert X rotation to radians
                const rotationYRad = (rotationYDeg * Math.PI) / 180;            // <-- Convert Y rotation to radians
                const rotationZRad = (rotationZDeg * Math.PI) / 180;            // <-- Convert Z rotation to radians
                
                // Find the existing root nodes (GLB may have coordinate system conversion node)
                // We need to find the top-level parent to maintain hierarchy
                const rootTransformNodes = meshes
                    .map(mesh => {
                        let node = mesh;
                        while (node.parent) {
                            node = node.parent;                                 // <-- Walk up to root
                        }
                        return node;
                    })
                    .filter((node, index, self) => self.indexOf(node) === index);  // <-- Get unique roots
                
                // Create parent TransformNode for master global rotation around world origin (0,0,0)
                const rotationParent = new BABYLON.TransformNode("modelRotationParent", scene);  // <-- Create parent transform node
                rotationParent.position = BABYLON.Vector3.Zero();               // <-- Position at world origin (0,0,0)
                
                // Check if translation parent exists (translation should be applied first)
                const translationParent = scene.getNodeByName("modelTranslationParent");
                
                // If translation parent exists, parent rotation parent to translation parent first
                // Then reparent all root nodes from translation parent to rotation parent
                if (translationParent) {
                    rotationParent.parent = translationParent;                  // <-- Parent rotation to translation parent
                    
                    // Find all direct children of translation parent and reparent them to rotation parent
                    const translationChildren = translationParent.getChildren().slice();  // <-- Create copy to avoid modification during iteration
                    translationChildren.forEach(child => {
                        if (child.name !== "modelRotationParent") {            // <-- Avoid self-parenting
                            child.parent = rotationParent;                      // <-- Reparent to rotation parent
                        }
                    });
                } else {
                    // No translation parent exists, parent root nodes directly to rotation parent
                    rootTransformNodes.forEach(rootNode => {
                        if (rootNode && rootNode.name !== "modelRotationParent") {  // <-- Avoid self-parenting
                            rootNode.parent = rotationParent;                  // <-- Parent root to rotation node
                        }
                    });
                }
                
                // Apply rotation to parent node (rotates entire hierarchy around world origin)
                rotationParent.rotation = new BABYLON.Vector3(rotationXRad, rotationYRad, rotationZRad);  // <-- Set rotation as Vector3
                
                // Log rotation application if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log('=== Global Model Rotation Applied ===');
                    console.log(`Rotation Pivot: World Origin (0, 0, 0)`);
                    console.log(`Root nodes found: ${rootTransformNodes.length}`);
                    console.log(`Rotation X: ${rotationXDeg}Â° (${rotationXRad.toFixed(4)} rad)`);
                    console.log(`Rotation Y: ${rotationYDeg}Â° (${rotationYRad.toFixed(4)} rad)`);
                    console.log(`Rotation Z: ${rotationZDeg}Â° (${rotationZRad.toFixed(4)} rad)`);
                    console.log(`Total meshes affected: ${meshes.length}`);
                    console.log(`=====================================`);
                }
                
                return rotationParent;                                          // <-- Return parent node for future reference
            }
            // ---------------------------------------------------------------
            
            // HELPER FUNCTION | Apply Global Translation to Model Meshes
            // ---------------------------------------------------------------
            function applyGlobalModelTranslation(meshes, scene, translationX, translationY, translationZ) {
                if (meshes.length === 0) return;                                // <-- Exit if no meshes
                
                // Find the existing root nodes (GLB may have coordinate system conversion node)
                // We need to find the top-level parent to maintain hierarchy
                const rootTransformNodes = meshes
                    .map(mesh => {
                        let node = mesh;
                        while (node.parent) {
                            node = node.parent;                                 // <-- Walk up to root
                        }
                        return node;
                    })
                    .filter((node, index, self) => self.indexOf(node) === index);  // <-- Get unique roots
                
                // Create parent TransformNode for master global translation
                const translationParent = new BABYLON.TransformNode("modelTranslationParent", scene);  // <-- Create parent transform node
                translationParent.position = new BABYLON.Vector3(translationX, translationY, translationZ);  // <-- Set translation position
                
                // Parent all root nodes (including coordinate system conversion) to translation node
                rootTransformNodes.forEach(rootNode => {
                    if (rootNode && rootNode.name !== "modelTranslationParent" && rootNode.name !== "modelRotationParent") {  // <-- Avoid self-parenting and preserve rotation parent if exists
                        rootNode.parent = translationParent;                    // <-- Parent root to translation node
                    }
                });
                
                // Log translation application if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log('=== Global Model Translation Applied ===');
                    console.log(`Root nodes found: ${rootTransformNodes.length}`);
                    console.log(`Translation X: ${translationX} units`);
                    console.log(`Translation Y: ${translationY} units`);
                    console.log(`Translation Z: ${translationZ} units`);
                    console.log(`Total meshes affected: ${meshes.length}`);
                    console.log(`==========================================`);
                }
                
                return translationParent;                                        // <-- Return parent node for future reference
            }
            // ---------------------------------------------------------------
            
            // HELPER FUNCTION | Center Model at Origin
            // ---------------------------------------------------------------
            function centerModelAtOrigin(meshes, bounds) {
                if (!meshes || meshes.length === 0) return;                     // <-- Exit if no meshes
                if (!bounds || !bounds.center) return;                          // <-- Exit if no bounds
                
                const center = bounds.center;                                   // <-- Get center point
                
                // Move all meshes to center model at world origin
                meshes.forEach(mesh => {
                    if (mesh.position) {
                        mesh.position.subtractInPlace(center);                  // <-- Move to origin
                    }
                });
                
                // Log centering if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log('Model centered at origin');
                }
            }
            // ---------------------------------------------------------------
            
            // HELPER FUNCTION | Adjust Camera Position to Frame Model
            // ---------------------------------------------------------------
            function adjustCameraToModel(scene, bounds) {
                const camera = scene.activeCamera;                           // <-- Get active camera
                if (!camera) return;                                         // <-- Exit if no camera
                
                // Get distance multiplier from configuration
                const distanceMultiplier = getConfigValue(modelConfig, 'model_CameraDistanceMultiplier', 2.0);
                const distance = bounds.maxDimension * distanceMultiplier;   // <-- Calculate appropriate distance
                
                camera.position = new BABYLON.Vector3(
                    distance * 0.5,                                          // <-- Position to side
                    distance * 0.5,                                          // <-- Position above
                    -distance                                                // <-- Position back
                );
                
                camera.setTarget(BABYLON.Vector3.Zero());                    // <-- Look at model center
                
                // Log camera position if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log('=== Camera Positioned ===');
                    console.log(`Position: ${camera.position.toString()}`);
                    console.log(`Distance: ${distance.toFixed(2)} units`);
                    console.log(`Multiplier: ${distanceMultiplier}x`);
                    console.log('========================');
                }
            }
            // ---------------------------------------------------------------
            
        // endregion -------------------------------------------------------------------
        
        
        // -----------------------------------------------------------------------------
        // REGION | React Component Structure
        // -----------------------------------------------------------------------------
        
            const { useEffect, useRef, useState } = React;
            
            // FUNCTION | Main Whitecard Viewer Component
            // ------------------------------------------------------------
            function WhitecardViewer() {
                const canvasRef          = useRef(null);                     // <-- Canvas element reference
                const engineRef          = useRef(null);                     // <-- Babylon engine reference
                const sceneRef           = useRef(null);                     // <-- Babylon scene reference
                const [isLoading, setIsLoading] = useState(true);            // <-- Loading state
                const [loadError, setLoadError] = useState(null);            // <-- Error state
                
                // SUB FUNCTION | Initialize Babylon.js Scene and Load Model
                // ---------------------------------------------------------------
                useEffect(() => {
                    if (!canvasRef.current) return;                          // <-- Exit if canvas not ready
                    
                    initializeBabylonScene();                                // <-- Set up Babylon scene
                    
                    return () => {                                           // <-- Cleanup on unmount
                        cleanupBabylonResources();                           // <-- Dispose resources
                    };
                }, []);
                // ---------------------------------------------------------------
                
                // FUNCTION | Initialize Complete Babylon Scene
                // ------------------------------------------------------------
                function initializeBabylonScene() {
                    try {
                        const canvas = canvasRef.current;                    // <-- Get canvas element
                        
                        // Create Babylon engine with antialiasing
                        const engine = new BABYLON.Engine(canvas, true, { 
                            preserveDrawingBuffer: true, 
                            stencil: true 
                        });
                        engineRef.current = engine;                          // <-- Store engine reference
                        
                        // Create scene
                        const scene = new BABYLON.Scene(engine);             // <-- Initialize scene
                        sceneRef.current = scene;                            // <-- Store scene reference
                        
                        setupSceneEnvironment(scene);                        // <-- Configure scene environment
                        setupCamera(scene, canvas);                          // <-- Configure FPS camera
                        setupKeyboardControls(scene);                        // <-- Setup keyboard shortcuts
                        loadModelWithWhitecardMaterial(scene, setIsLoading, setLoadError);  // <-- Load model with whitecard material
                        setupRenderLoop(engine, scene);                       // <-- Start render loop
                        setupWindowResize(engine);                           // <-- Handle window resize
                        
                    } catch (error) {
                        console.error('Babylon initialization error:', error);  // <-- Log errors
                        setLoadError(error.message);                         // <-- Set error state
                        setIsLoading(false);                                 // <-- Stop loading indicator
                    }
                }
                // ---------------------------------------------------------------
                
                return (
                    <>
                        <canvas ref={canvasRef} id="renderCanvas" />
                        {isLoading && (
                            <div className="loading-indicator">
                                Loading Whitecard Model...
                            </div>
                        )}
                        {loadError && (
                            <div className="loading-indicator" style={{color: '#cc0000'}}>
                                Error: {loadError}
                            </div>
                        )}
                        {appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true && (
                            <div className="debug-info">
                                <h4>ðŸ”§ Debug Info</h4>
                                <p><strong>App:</strong> {appMetadata?.appName} v{appMetadata?.appVersion}</p>
                                <p><strong>Controls:</strong> WASD = Move | Q = Down | E = Up | Mouse = Look</p>
                                <p><strong>Shortcuts:</strong> H or X = Toggle Axis Helper</p>
                                <p><strong>Speed:</strong> {navConfig?.navigationMode_MoveSpeed_MPH} MPH</p>
                                <p><strong>Dev Mode:</strong> Active</p>
                                <p style={{fontSize: '0.75rem', marginTop: '8px', opacity: 0.7}}>
                                    Check console for detailed logs
                                </p>
                            </div>
                        )}
                    </>
                );
            }
            // ---------------------------------------------------------------
            
        // endregion -------------------------------------------------------------------
        
        
        // -----------------------------------------------------------------------------
        // REGION | Babylon Scene Configuration
        // -----------------------------------------------------------------------------
        
            // FUNCTION | Setup Scene Environment and Lighting
            // ------------------------------------------------------------
            function setupSceneEnvironment(scene) {
                // Set background color from configuration
                const bgR = getConfigValue(renderConfig, 'render_BackgroundColor_R', 1.0);
                const bgG = getConfigValue(renderConfig, 'render_BackgroundColor_G', 1.0);
                const bgB = getConfigValue(renderConfig, 'render_BackgroundColor_B', 1.0);
                const bgA = getConfigValue(renderConfig, 'render_BackgroundColor_A', 1.0);
                scene.clearColor = new BABYLON.Color4(bgR, bgG, bgB, bgA);  // <-- Background from config
                
                // Create hemisphere light for soft ambient lighting
                const light = new BABYLON.HemisphericLight(
                    "hemisphereLight",                                       // <-- Light name
                    new BABYLON.Vector3(0, 1, 0),                           // <-- Light direction (upward)
                    scene                                                    // <-- Parent scene
                );
                
                // Configure light from configuration
                light.intensity = getConfigValue(lightingConfig, 'lighting_HemisphereIntensity', 1.0);
                
                light.diffuse = new BABYLON.Color3(
                    getConfigValue(lightingConfig, 'lighting_HemisphereDiffuse_R', 1.0),
                    getConfigValue(lightingConfig, 'lighting_HemisphereDiffuse_G', 1.0),
                    getConfigValue(lightingConfig, 'lighting_HemisphereDiffuse_B', 1.0)
                );
                
                light.specular = new BABYLON.Color3(
                    getConfigValue(lightingConfig, 'lighting_HemisphereSpecular_R', 0.1),
                    getConfigValue(lightingConfig, 'lighting_HemisphereSpecular_G', 0.1),
                    getConfigValue(lightingConfig, 'lighting_HemisphereSpecular_B', 0.1)
                );
                
                light.groundColor = new BABYLON.Color3(
                    getConfigValue(lightingConfig, 'lighting_HemisphereGround_R', 0.9),
                    getConfigValue(lightingConfig, 'lighting_HemisphereGround_G', 0.9),
                    getConfigValue(lightingConfig, 'lighting_HemisphereGround_B', 0.9)
                );
                
                // Add subtle directional light for form definition
                const dirLight = new BABYLON.DirectionalLight(
                    "directionalLight",                                      // <-- Light name
                    new BABYLON.Vector3(
                        getConfigValue(lightingConfig, 'lighting_DirectionalDirection_X', -0.5),
                        getConfigValue(lightingConfig, 'lighting_DirectionalDirection_Y', -1.0),
                        getConfigValue(lightingConfig, 'lighting_DirectionalDirection_Z', -0.3)
                    ),                                                        // <-- Light direction
                    scene                                                     // <-- Parent scene
                );
                
                dirLight.intensity = getConfigValue(lightingConfig, 'lighting_DirectionalIntensity', 0.3);
                dirLight.diffuse = new BABYLON.Color3(1.0, 1.0, 1.0);        // <-- Pure white light
                dirLight.specular = new BABYLON.Color3(0.0, 0.0, 0.0);       // <-- No specular from directional
                
                // Add debug helpers if dev mode enabled - store reference for toggling
                scene.axisHelper = null;                                     // <-- Initialize axis helper reference
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowAxisHelper === true) {
                    const axisSize = 5;                                      // <-- Axis helper size
                    scene.axisHelper = new BABYLON.AxesViewer(scene, axisSize);  // <-- Create axis helper
                    console.log('Axis helper enabled (size:', axisSize, ')');
                }
                
                // FUNCTION | Toggle Axis Helper Visibility
                // ---------------------------------------------------------------
                scene.toggleAxisHelper = function() {
                    if (scene.axisHelper) {
                        scene.axisHelper.dispose();                           // <-- Remove axis helper
                        scene.axisHelper = null;                             // <-- Clear reference
                        console.log('Axis helper disabled');
                    } else {
                        const axisSize = 5;                                  // <-- Axis helper size
                        scene.axisHelper = new BABYLON.AxesViewer(scene, axisSize);  // <-- Create axis helper
                        console.log('Axis helper enabled (size:', axisSize, ')');
                    }
                };
                // ---------------------------------------------------------------
            }
            // ---------------------------------------------------------------
            
        // endregion -------------------------------------------------------------------
        
        
        // -----------------------------------------------------------------------------
        // REGION | Camera Configuration - FPS Controls
        // -----------------------------------------------------------------------------
        
            // FUNCTION | Setup Universal Camera with FPS Controls
            // ------------------------------------------------------------
            function setupCamera(scene, canvas) {
                // Create Universal Camera for FPS-style navigation
                const camera = new BABYLON.UniversalCamera(
                    "fpsCamera",                                             // <-- Camera name
                    new BABYLON.Vector3(0, 5, -10),                         // <-- Initial position (back and up)
                    scene                                                    // <-- Parent scene
                );
                
                camera.setTarget(BABYLON.Vector3.Zero());                    // <-- Look at origin
                camera.attachControl(canvas, true);                          // <-- Enable mouse control
                
                // Configure WASD keyboard controls
                camera.keysUp      = [87];                                   // <-- W key for forward
                camera.keysDown    = [83];                                   // <-- S key for backward
                camera.keysLeft    = [65];                                   // <-- A key for left
                camera.keysRight   = [68];                                   // <-- D key for right
                
                // Configure Q/E vertical navigation controls
                camera.keysUpward     = [69];                                // <-- E key for up
                camera.keysDownward   = [81];                                // <-- Q key for down
                
                // Configure movement and rotation speeds from configuration
                const speedMPH = getConfigValue(navConfig, 'navigationMode_MoveSpeed_MPH', 5.0);
                camera.speed = convertMPHtoBabylonSpeed(speedMPH);          // <-- Convert MPH to Babylon units
                
                camera.angularSensibility = getConfigValue(navConfig, 'navigationMode_AngularSensitivity', 1000);
                camera.inertia = getConfigValue(navConfig, 'navigationMode_Inertia', 0.5);
                
                // Configure collision and gravity from configuration
                camera.checkCollisions = getConfigValue(navConfig, 'navigationMode_EnableCollision', false);
                camera.applyGravity = getConfigValue(navConfig, 'navigationMode_EnableGravity', false);
                
                // Log camera configuration if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log('=== Camera Configuration ===');
                    console.log(`Speed: ${speedMPH} MPH (${camera.speed.toFixed(3)} units/sec)`);
                    console.log(`Angular Sensitivity: ${camera.angularSensibility}`);
                    console.log(`Inertia: ${camera.inertia}`);
                    console.log(`Collision: ${camera.checkCollisions}`);
                    console.log(`Gravity: ${camera.applyGravity}`);
                    console.log(`Controls: WASD = Move | Q = Down | E = Up | Mouse = Look`);
                    console.log('===========================');
                }
                
                // Add camera position logging if enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_LogCameraPosition === true) {
                    scene.registerBeforeRender(() => {
                        if (Math.random() < 0.01) {                          // <-- Log 1% of frames to avoid spam
                            console.log(`Camera Position: ${camera.position.toString()}`);
                        }
                    });
                }
                
                return camera;                                               // <-- Return camera reference
            }
            // ---------------------------------------------------------------
            
        // endregion -------------------------------------------------------------------
        
        
        // -----------------------------------------------------------------------------
        // REGION | Whitecard Material and Edge Rendering
        // -----------------------------------------------------------------------------
        
            // FUNCTION | Create Whitecard Material with Subtle Shading
            // ------------------------------------------------------------
            function createWhitecardMaterial(scene) {
                // Create standard material for whitecard aesthetic
                const whiteMaterial = new BABYLON.StandardMaterial("whitecardMaterial", scene);
                
                // Set material colors for clean white appearance
                whiteMaterial.diffuseColor = new BABYLON.Color3(0.95, 0.95, 0.95);   // <-- Slightly off-white
                whiteMaterial.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);  // <-- Minimal specularity
                whiteMaterial.ambientColor = new BABYLON.Color3(0.9, 0.9, 0.9);      // <-- Bright ambient
                whiteMaterial.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.05);  // <-- Slight self-illumination
                
                // Additional material properties
                whiteMaterial.specularPower = 64;                                    // <-- Sharp specular highlight
                whiteMaterial.useSpecularOverAlpha = false;                          // <-- No transparency effects
                whiteMaterial.backFaceCulling = true;                                // <-- Cull back faces
                
                // Log material configuration if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log('=== Whitecard Material Configuration ===');
                    console.log(`Diffuse: ${whiteMaterial.diffuseColor.toString()}`);
                    console.log(`Specular: ${whiteMaterial.specularColor.toString()}`);
                    console.log(`Ambient: ${whiteMaterial.ambientColor.toString()}`);
                    console.log(`Emissive: ${whiteMaterial.emissiveColor.toString()}`);
                    console.log('=======================================');
                }
                
                return whiteMaterial;                                                // <-- Return configured material
            }
            // ---------------------------------------------------------------
            
            // FUNCTION | Apply Edge Rendering with Universal Smoothing
            // ------------------------------------------------------------
            function applyEdgeRendering(mesh) {
                // Get edge configuration values
                const edgeWidth         = getConfigValue(edgeConfig, 'edge_Width', 2.0);
                const edgeColorR        = getConfigValue(edgeConfig, 'edge_Color_R', 13) / 255.0;    // <-- Convert from 255-based to float
                const edgeColorG        = getConfigValue(edgeConfig, 'edge_Color_G', 13) / 255.0;    // <-- Convert from 255-based to float
                const edgeColorB        = getConfigValue(edgeConfig, 'edge_Color_B', 13) / 255.0;    // <-- Convert from 255-based to float
                const smoothingAngle    = getConfigValue(edgeConfig, 'edge_SmoothingAngle', 35);
                
                // Calculate threshold based on smoothing angle
                // Convert angle to radians and use cosine for dot product threshold
                // Babylon.js edge rendering uses face normal dot product: edges below this threshold are hidden
                const angleRadians = (smoothingAngle * Math.PI) / 180;              // <-- Convert to radians
                const edgeThreshold = Math.cos(angleRadians);                        // <-- Cosine threshold (lower = fewer edges shown)
                
                // Enable edge rendering on the mesh with universal threshold
                try {
                    mesh.enableEdgesRendering(edgeThreshold);                        // <-- Universal threshold for all meshes
                    mesh.edgesWidth = edgeWidth;                                      // <-- Set edge width
                    mesh.edgesColor = new BABYLON.Color4(edgeColorR, edgeColorG, edgeColorB, 1.0);  // <-- Dark grey/black edges
                    
                    // Log edge application if dev mode enabled
                    if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                        console.log(`Edge rendering applied to ${mesh.name}: Threshold=${edgeThreshold.toFixed(3)} (${smoothingAngle}Â°)`);
                    }
                    
                    return true;                                                     // <-- Success
                } catch (error) {
                    console.warn(`Could not apply edge rendering to mesh: ${mesh.name}`, error);
                    return false;                                                    // <-- Failed
                }
            }
            // ---------------------------------------------------------------
            
            // FUNCTION | Apply Edge Detection Post-Process for Profile Edges (SketchUp-Style)
            // ---------------------------------------------------------------
            function applyOutlineRendering(scene, meshes) {
                // Check if silhouette edges are enabled
                const enableSilhouettes = getConfigValue(edgeConfig, 'edge_EnableSilhouetteEdges', true);
                if (!enableSilhouettes) return null;                                // <-- Skip if disabled
                
                // Get edge color for profiles (convert from 255-based to float)
                const edgeColorR = getConfigValue(edgeConfig, 'edge_Color_R', 13) / 255.0;
                const edgeColorG = getConfigValue(edgeConfig, 'edge_Color_G', 13) / 255.0;
                const edgeColorB = getConfigValue(edgeConfig, 'edge_Color_B', 13) / 255.0;
                
                // Profile intensity multiplier for Sobel edge detection (driven by JSON config)
                const profileIntensity = getConfigValue(lineStylesConfig, 'lineStyles_ProfileIntensity', 10.0);
                const curvedSurfaceBoost = getConfigValue(lineStylesConfig, 'lineStyles_CurvedSurfaceBoost', 4.0);
                
                try {
                    // Register custom edge detection shader in Babylon.js shader store
                    BABYLON.Effect.ShadersStore["edgeDetectionFragmentShader"] = `
                        #ifdef GL_ES
                            precision highp float;
                        #endif
                        
                        // Samplers
                        varying vec2 vUV;
                        uniform sampler2D textureSampler;
                        uniform sampler2D depthSampler;
                        uniform vec2 screenSize;
                        uniform float edgeIntensity;
                        uniform float curvedBoost;
                        uniform vec3 edgeColor;
                        
                        void main(void) {
                            // Calculate pixel size for sampling neighbors
                            vec2 pixelSize = vec2(1.0) / screenSize;
                            
                            // Sample center depth for distance-based adjustments
                            float centerDepth = texture2D(depthSampler, vUV).r;
                            
                            // Calculate distance from depth (0=far, 1=near, so invert)
                            float distance = 1.0 - centerDepth;
                            
                            // Sobel edge detection kernel on depth buffer
                            // Sample 8 surrounding pixels for depth discontinuities
                            float d1 = texture2D(depthSampler, vUV + vec2(-pixelSize.x, -pixelSize.y)).r;
                            float d2 = texture2D(depthSampler, vUV + vec2(0.0, -pixelSize.y)).r;
                            float d3 = texture2D(depthSampler, vUV + vec2(pixelSize.x, -pixelSize.y)).r;
                            float d4 = texture2D(depthSampler, vUV + vec2(-pixelSize.x, 0.0)).r;
                            float d6 = texture2D(depthSampler, vUV + vec2(pixelSize.x, 0.0)).r;
                            float d7 = texture2D(depthSampler, vUV + vec2(-pixelSize.x, pixelSize.y)).r;
                            float d8 = texture2D(depthSampler, vUV + vec2(0.0, pixelSize.y)).r;
                            float d9 = texture2D(depthSampler, vUV + vec2(pixelSize.x, pixelSize.y)).r;
                            
                            // Sobel horizontal and vertical gradients
                            float sobelX = (d3 + 2.0 * d6 + d9) - (d1 + 2.0 * d4 + d7);
                            float sobelY = (d7 + 2.0 * d8 + d9) - (d1 + 2.0 * d2 + d3);
                            
                            // Calculate edge magnitude
                            float edge = sqrt(sobelX * sobelX + sobelY * sobelY);
                            
                            // Scale edge detection sensitivity
                            edge = edge * edgeIntensity;
                            
                            // Enhanced edge boosting for curved surfaces
                            // Use smoothstep for cleaner transitions without noise amplification
                            edge = smoothstep(0.0, 0.4, edge);                      // <-- Smooth transition from 0 to 0.4
                            
                            // Additional boost for subtle edges on curved surfaces (but not noise)
                            // Only boost edges that are strong enough to be real, not noise
                            float boostThreshold = 0.05 + distance * 0.05;           // <-- Higher threshold for distant objects
                            if (edge > boostThreshold && edge < 0.4) {               // <-- Boost medium-strength edges
                                edge = edge * curvedBoost;                           // <-- Configurable boost for curved surface profiles
                            }
                            
                            edge = clamp(edge, 0.0, 1.0);
                            
                            // Distance-based threshold to reduce noise on distant objects
                            float dynamicThreshold = 0.2 + distance * 0.1;           // <-- Higher threshold for distant objects
                            
                            // Apply threshold to create crisp edges without greying surfaces
                            // Use sharp cutoff to prevent grey bleeding
                            float edgeStrength = 0.0;
                            if (edge > dynamicThreshold) {
                                // Sharp transition using smoothstep for clean edges
                                float upperThreshold = dynamicThreshold + 0.05;      // <-- Narrow transition zone
                                edgeStrength = smoothstep(dynamicThreshold, upperThreshold, edge);
                                
                                // Make it even sharper - binary decision for very clean edges
                                edgeStrength = edgeStrength > 0.5 ? 1.0 : edgeStrength * 0.5;
                            }
                            
                            // Get original scene color
                            vec4 baseColor = texture2D(textureSampler, vUV);
                            
                            // Blend edge color with scene only where edges detected
                            vec3 finalColor = mix(baseColor.rgb, edgeColor, edgeStrength);
                            
                            gl_FragColor = vec4(finalColor, baseColor.a);
                        }
                    `;
                    
                    // Create post-process with custom shader
                    const edgeDetection = new BABYLON.PostProcess(
                        "edgeDetection",                                             // <-- Post-process name
                        "edgeDetection",                                             // <-- Shader name (from shader store)
                        ["screenSize", "edgeIntensity", "curvedBoost", "edgeColor"], // <-- Uniforms
                        ["depthSampler"],                                            // <-- Additional samplers
                        1.0,                                                         // <-- Sampling ratio (1.0 = full resolution)
                        scene.activeCamera,                                          // <-- Attach to camera
                        BABYLON.Texture.BILINEAR_SAMPLINGMODE                        // <-- Sampling mode
                    );
                    
                    // Configure post-process uniforms
                    edgeDetection.onApply = function (effect) {
                        effect.setVector2("screenSize", new BABYLON.Vector2(
                            scene.getEngine().getRenderWidth(),
                            scene.getEngine().getRenderHeight()
                        ));
                        effect.setFloat("edgeIntensity", profileIntensity * 50.0);   // <-- Edge sensitivity
                        effect.setFloat("curvedBoost", curvedSurfaceBoost);          // <-- Curved surface boost multiplier
                        effect.setVector3("edgeColor", new BABYLON.Vector3(edgeColorR, edgeColorG, edgeColorB));
                        effect.setTexture("depthSampler", scene.enableDepthRenderer().getDepthMap());
                    };
                    
                    if (appConfig?.devMode_Enabled === true) {
                        console.log(`SketchUp-style profile edge detection enabled | Intensity: ${profileIntensity}x | Curved Boost: ${curvedSurfaceBoost}x`);
                    }
                    
                    return edgeDetection;                                            // <-- Return post-process reference
                    
                } catch (error) {
                    console.warn('Could not create edge detection post-process:', error);
                    return null;
                }
            }
            // ---------------------------------------------------------------
            
        // endregion -------------------------------------------------------------------
        
        
        // -----------------------------------------------------------------------------
        // REGION | Keyboard Controls and Shortcuts
        // -----------------------------------------------------------------------------
        
            // FUNCTION | Setup Keyboard Shortcuts
            // ------------------------------------------------------------
            function setupKeyboardControls(scene) {
                // Add keyboard event listener for shortcuts
                window.addEventListener('keydown', function(event) {
                    // Only process if not typing in an input field
                    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                        return;                                              // <-- Ignore when typing
                    }
                    
                    // Toggle axis helper with 'H' or 'X' key
                    const key = event.key.toLowerCase();                      // <-- Get lowercase key
                    if ((key === 'h' || key === 'x') && scene && scene.toggleAxisHelper) {
                        scene.toggleAxisHelper();                            // <-- Toggle axis helper visibility
                        event.preventDefault();                                // <-- Prevent default browser behavior
                    }
                });
                
                // Log keyboard controls if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log('=== Keyboard Controls ===');
                    console.log('H or X = Toggle Axis Helper');
                    console.log('WASD = Move | Q = Down | E = Up | Mouse = Look');
                    console.log('========================');
                }
            }
            // ---------------------------------------------------------------
            
        // endregion -------------------------------------------------------------------
        
        
        // -----------------------------------------------------------------------------
        // REGION | Model Loading and Material Application
        // -----------------------------------------------------------------------------
        
            // FUNCTION | Load GLB Model and Apply Whitecard Material
            // ------------------------------------------------------------
            function loadModelWithWhitecardMaterial(scene, setIsLoading, setLoadError) {
                // Get model URL from configuration
                const modelUrl = getConfigValue(modelConfig, 'model_DefaultURL', 
                    "https://cdn.noble-architecture.com/VaApps/3dAssets/Test__SketchUpExport__UsingOwnGlbExporter__3.0.0__.glb"
                );
                
                // Log model loading if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log('=== Model Loading ===');
                    console.log(`URL: ${modelUrl}`);
                    console.log(`Auto Center: ${getConfigValue(modelConfig, 'model_AutoCenter', true)}`);
                    console.log(`Auto Frame: ${getConfigValue(modelConfig, 'model_AutoFrameCamera', true)}`);
                    console.log('====================');
                }
                
                // Create whitecard material
                const whitecardMaterial = createWhitecardMaterial(scene);   // <-- Create whitecard material
                
                // Load the GLB model
                BABYLON.SceneLoader.ImportMesh(
                    "",                                                      // <-- Load all meshes
                    "",                                                      // <-- Base URL (empty, using full URL)
                    modelUrl,                                                // <-- Full model URL
                    scene,                                                   // <-- Target scene
                    function(meshes) {                                       // <-- Success callback
                        handleModelLoadSuccess(meshes, whitecardMaterial, scene, setIsLoading);
                    },
                    null,                                                    // <-- Progress callback
                    function(scene, message, exception) {                   // <-- Error callback
                        handleModelLoadError(message, exception, setIsLoading, setLoadError);
                    }
                );
            }
            // ---------------------------------------------------------------
            
            // SUB FUNCTION | Handle Successful Model Load
            // ---------------------------------------------------------------
            function handleModelLoadSuccess(meshes, material, scene, setIsLoading) {
                console.log(`Loaded ${meshes.length} meshes`);              // <-- Log mesh count
                
                // Ensure proper normals for all meshes (universal smoothing)
                preprocessMeshesForSmoothing(meshes);                       // <-- Preprocess all meshes universally
                
                // Apply global translation transformation first (macro controls)
                const translationX = getConfigValue(modelConfig, 'model_Translation_X', 0);    // <-- Get X translation in units
                const translationY = getConfigValue(modelConfig, 'model_Translation_Y', 0);    // <-- Get Y translation in units
                const translationZ = getConfigValue(modelConfig, 'model_Translation_Z', 0);    // <-- Get Z translation in units
                if (translationX !== 0 || translationY !== 0 || translationZ !== 0) {
                    applyGlobalModelTranslation(meshes, scene, translationX, translationY, translationZ);   // <-- Apply translation transformation
                }
                
                // Apply global rotation transformation second (macro controls)
                const rotationX = getConfigValue(modelConfig, 'model_Rotation_X', 0);    // <-- Get X rotation in degrees
                const rotationY = getConfigValue(modelConfig, 'model_Rotation_Y', 0);    // <-- Get Y rotation in degrees
                const rotationZ = getConfigValue(modelConfig, 'model_Rotation_Z', 0);    // <-- Get Z rotation in degrees
                if (rotationX !== 0 || rotationY !== 0 || rotationZ !== 0) {
                    applyGlobalModelRotation(meshes, scene, rotationX, rotationY, rotationZ);   // <-- Apply rotation transformation
                }
                
                // Apply material and edge rendering to all meshes
                let edgeRenderingCount = 0;                                 // <-- Track successful edge applications
                
                meshes.forEach(mesh => {
                    if (mesh.material || mesh.subMeshes) {                   // <-- Only process renderable meshes
                        mesh.material = material;                            // <-- Apply whitecard material
                        
                        // Apply edge rendering to this mesh
                        if (applyEdgeRendering(mesh)) {
                            edgeRenderingCount++;                            // <-- Count successful applications
                        }
                    }
                });
                
                // Apply outline rendering for better silhouettes
                applyOutlineRendering(scene, meshes);                       // <-- Add outline pass
                
                // Log edge rendering results if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log(`=== Edge Rendering Applied ===`);
                    console.log(`Meshes with edges: ${edgeRenderingCount}/${meshes.length}`);
                    console.log(`Edge Width: ${getConfigValue(edgeConfig, 'edge_Width', 2.0)}px`);
                    console.log(`Smoothing Angle: ${getConfigValue(edgeConfig, 'edge_SmoothingAngle', 35)}Â°`);
                    console.log(`==============================`);
                }
                
                // Calculate bounding box for all meshes
                const bounds = calculateSceneBounds(meshes);                 // <-- Get model bounds
                
                // Log model bounds if dev mode enabled
                if (appConfig?.devMode_Enabled === true && appConfig?.devMode_ShowDebugInfo === true) {
                    console.log('=== Model Bounds ===');
                    console.log(`Center: ${bounds.center.toString()}`);
                    console.log(`Size: ${bounds.size.toString()}`);
                    console.log(`Max Dimension: ${bounds.maxDimension.toFixed(2)}`);
                    console.log('===================');
                }
                
                // Center model at origin if configured
                const shouldCenter = getConfigValue(modelConfig, 'model_AutoCenter', true);
                if (shouldCenter === true) {
                    centerModelAtOrigin(meshes, bounds);                     // <-- Center model at origin
                }
                
                // Position camera based on model size if configured
                const shouldFrameCamera = getConfigValue(modelConfig, 'model_AutoFrameCamera', true);
                if (shouldFrameCamera === true) {
                    adjustCameraToModel(scene, bounds);                      // <-- Position camera appropriately
                }
                
                if (setIsLoading) {
                    setIsLoading(false);                                     // <-- Hide loading indicator
                }
            }
            // ---------------------------------------------------------------
            
            // SUB FUNCTION | Handle Model Load Error
            // ---------------------------------------------------------------
            function handleModelLoadError(message, exception, setIsLoading, setLoadError) {
                console.error('Model load error:', message, exception);      // <-- Log error details
                if (setLoadError) {
                    setLoadError(message || 'Failed to load model');         // <-- Set error state
                }
                if (setIsLoading) {
                    setIsLoading(false);                                     // <-- Hide loading indicator
                }
            }
            // ---------------------------------------------------------------
            
        // endregion -------------------------------------------------------------------
        
        
        // -----------------------------------------------------------------------------
        // REGION | Rendering Pipeline
        // -----------------------------------------------------------------------------
        
            // FUNCTION | Setup Render Loop
            // ------------------------------------------------------------
            function setupRenderLoop(engine, scene) {
                engine.runRenderLoop(() => {
                    scene.render();                                          // <-- Render scene each frame
                });
            }
            // ---------------------------------------------------------------
            
            // FUNCTION | Setup Window Resize Handler
            // ------------------------------------------------------------
            function setupWindowResize(engine) {
                window.addEventListener('resize', () => {
                    engine.resize();                                         // <-- Resize engine on window resize
                });
            }
            // ---------------------------------------------------------------
            
            // FUNCTION | Cleanup Babylon Resources
            // ------------------------------------------------------------
            function cleanupBabylonResources() {
                if (sceneRef.current) {
                    sceneRef.current.dispose();                              // <-- Dispose scene
                    sceneRef.current = null;                                 // <-- Clear reference
                }
                
                if (engineRef.current) {
                    engineRef.current.dispose();                             // <-- Dispose engine
                    engineRef.current = null;                                // <-- Clear reference
                }
            }
            // ---------------------------------------------------------------
            
        // endregion -------------------------------------------------------------------
        
        
        // -----------------------------------------------------------------------------
        // REGION | React Application Bootstrap
        // -----------------------------------------------------------------------------
        
            // FUNCTION | Initialize React Application
            // ------------------------------------------------------------
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<WhitecardViewer />);                                // <-- Render main component
            // ---------------------------------------------------------------
            
        // endregion -------------------------------------------------------------------
        
    </script>
    
    <!-- endregion -------------------------------------------------------- -->
    
</body>
</html>
